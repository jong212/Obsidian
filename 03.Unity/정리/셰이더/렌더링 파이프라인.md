## 렌더링 파이프 라인을 간단히 말하자면?

간단히 말하면 3D 화면을 2차원으로 표현하는 과정이다
>[!tip] 3D 화면을 왜 3차원으로 표시하지?
>유니티 엔진을 포함한 대부분의 3D 그래픽 엔진은 최종적으로 3D 데이터를 2D이미지로 변환해서 우리가 보는 화면에 렌더링을 한다고 함

위에서 말한 3D 데이터를 2D 이미지로 변환하는 과정이 바로 [[렌더링 파이프라인]] 이라고 함.

## 아직 렌더린 파이프라인의 개념이 잡히지 않았다 대체 뭘까
우선 2018년 이전의 유니티는 지금처럼 urp,hdrp 와 같은 파이프라인을 제공하지 않았고 <font color="#ffc000">빌트인</font>만 제공을 했었음
그 당시 유니티에서 공식적으로 지원하는 셰이더 제작 방법은 <font color="#ffc000">Surface Shader 라고 부르는 코딩 입력 방식</font>으로 셰이더를 작성했었는데
문제는 파이프라인이 유연하지 않고 사용자가 직접 세부 단게에 <font color="#ffc000">큰 영향을 미칠 수 없</font>었다고 함

그래서 유니티에서는 2018년부터 SRP란 이름의 새로운 렌더링 파이프라인을 공개했음 

그 이전 파이프라인은 빌트인으로 부르기로 결정했고 새로나온 SRP 파이프라인의<font color="#ffc000"> 두 가지</font> 템플릿으로 범용 작업을 하기 위해 <font color="#ffc000"> URP,HDRP</font> 파이프라인이 공개 됨

SRP 파이프라인은 유니티2 라고 불러도 될 정도로 빌트인파이프라인과 큰 차이가 있다고 함


## 렌더링 파이프 라인의 순서는?
### 1. **입력 어셈블리(Input Assembly)**

- 버텍스 데이터(Vertex Data): 3D 모델의 버텍스 데이터(위치, 색상, 법선, 텍스처 좌표 등)를 GPU로 전송합니다.
- 프리미티브 정의(Primitive Definition): 버텍스 데이터를 삼각형, 선, 점 등으로 조합하여 기본적인 렌더링 단위인 프리미티브를 정의합니다.

### 2. **버텍스 셰이더(Vertex Shader)**

- 모델 변환(Model Transform): 모델 공간의 버텍스 좌표를 월드 공간으로 변환합니다.
- 월드 변환(World Transform): 월드 공간의 버텍스 좌표를 카메라의 뷰 공간으로 변환합니다.
- 뷰 변환(View Transform): 뷰 공간의 버텍스 좌표를 클립 공간으로 변환합니다.
- 프로젝션 변환(Projection Transform): 클립 공간에서 화면 공간으로 변환하기 위해 투영 매트릭스를 적용합니다.
- 버텍스 출력(Vertex Output): 최종 변환된 버텍스 위치와 함께 텍스처 좌표, 색상, 법선 벡터 등의 데이터를 출력합니다.

### 3. **테셀레이션(Tessellation, 선택적 단계)**

- 테셀레이션 컨트롤 셰이더(Tessellation Control Shader): 입력된 버텍스를 세분화하기 위한 패치를 생성합니다.
- 테셀레이터(Tessellator): 패치를 세분화하여 더 많은 버텍스를 생성합니다.
- 테셀레이션 평가 셰이더(Tessellation Evaluation Shader): 세분화된 버텍스의 위치를 계산하고 최종적으로 뷰 및 프로젝션 변환을 적용합니다.

### 4. **지오메트리 셰이더(Geometry Shader, 선택적 단계)**

- 프리미티브 처리(Primitive Processing): 버텍스 셰이더의 출력 또는 테셀레이션의 결과물을 받아 프리미티브를 조작하거나 추가 프리미티브를 생성합니다.
- 출력(Output): 최종적으로 삼각형이나 선 등의 프리미티브를 출력합니다.

### 5. **라스터라이제이션(Rasterization)**

- 프러스텀 컬링(Frustum Culling): 카메라의 뷰 프러스텀 밖에 있는 프리미티브는 제거하여 렌더링을 최적화합니다.
- 스크린 스페이스 변환(Screen Space Transform): 클립 공간의 좌표를 화면 공간으로 변환하여 각 프리미티브를 2D 이미지로 변환합니다.
- 프래그먼트 생성(Fragment Generation): 각 픽셀에 대해 하나 이상의 프래그먼트를 생성합니다. 프래그먼트는 각 픽셀의 잠재적 색상과 텍스처 좌표, 깊이 정보를 포함합니다.

### 6. **프래그먼트 셰이더(Fragment Shader, 또는 픽셀 셰이더)**

- 조명 계산(Lighting Calculation): 각 프래그먼트에 대해 조명 모델(예: Phong, Blinn-Phong)을 적용하여 최종 색상을 계산합니다.
- 텍스처 샘플링(Texture Sampling): 프래그먼트의 텍스처 좌표를 이용해 텍스처 데이터를 가져와 적용합니다.
- 환경 맵핑(Environment Mapping): 반사, 굴절 등의 효과를 시뮬레이션하여 프래그먼트에 적용합니다.
- 출력(Output): 최종 색상, 알파(투명도), 깊이 값 등을 출력합니다.

### 7. **출력 병합 단계(Output Merger)**

- 깊이 테스트(Depth Testing): 깊이 버퍼를 사용하여 어떤 프래그먼트가 화면에 나타날지를 결정합니다.
- 스텐실 테스트(Stencil Testing): 스텐실 버퍼를 사용해 프래그먼트의 렌더링 여부를 결정합니다.
- 블렌딩(Blending): 여러 프래그먼트를 혼합하여 화면에 최종 색상을 결정합니다. 이는 주로 반투명 객체를 처리할 때 사용됩니다.
- 출력(Output): 최종 이미지가 프레임 버퍼에 저장되고, 이후 디스플레이에 렌더링됩니다.

### 8. **포스트 프로세싱(Post-Processing)**

- 블룸(Bloom): 밝은 부분이 번지는 효과를 적용합니다.
- 모션 블러(Motion Blur): 움직임에 따라 흐릿해지는 효과를 적용합니다.
- 색 보정(Color Grading): 최종 이미지의 색조, 명암, 채도를 조정합니다.
- 피사계 심도(Depth of Field): 특정 거리에 초점을 맞추고 다른 부분은 흐릿하게 보이게 만듭니다.














