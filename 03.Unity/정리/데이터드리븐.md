
| Git          | https://github.com/jong212/DataManager                                                                                                                                                                                                                                                    |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| BranchName   | 완성 브랜치명 : DatManagingExtension 체크아웃<br>분석 시작 커밋명 : 452e0e7 - [feat] DataManaging - 모델 추가                                                                                                                                                                                                  |
| RefFile      | 수업 자료 : https://drive.google.com/file/d/1gWbcaoAGcVyvnJUtf9JlJMD6upLsU-kh/view?usp=sharing<br>데이터 파일 : https://drive.google.com/file/d/1lev45TU8MoOt4ciPD8ZY7yPsCL_N5BAu/view?usp=sharing<br>수업 내용 : https://drive.google.com/drive/folders/1ePP7TJ8ZA16D93mQCyNeP6pzkhVMD90c?usp=sharing |
| Memo         |                                                                                                                                                                                                                                                                                           |
| MOC_Category | [[방법론 - MOC]]                                                                                                                                                                                                                                                                             |
|              |                                                                                                                                                                                                                                                                                           |

> [!tip]+ 데이터 드리븐 요약 사진
> ![[Pasted image 20240807222036.png]]

> [!tip]+ 모델 정의 - DataMapper.cs
> ### 모델을 정의하는 이유
> 모델을 정의하는 이유는 데이터 구조를 명확히 하고, 데이터를 효율적으로 관리하고 조작하기 위함입니다. 모델은 주로 데이터베이스 또는 외부 데이터 소스와 상호작용하기 위해 사용되며, 데이터 매퍼 패턴에서 중요한 역할을 합니다. 여기서 모델 클래스(Character, Skill, Buff)를 정의하는 이유는 다음과 같습니다:
> #### 1. 데이터 구조화
> 모델 클래스는 데이터를 객체 지향적으로 구조화합니다. 예를 들어, Character 클래스는 캐릭터의 ID, 이름, 설명, 아이콘 경로, 프리팹 경로, 그리고 스킬 리스트를 속성으로 가집니다. 이를 통해 데이터의 각 요소를 명확하게 정의하고, 데이터의 구조를 쉽게 이해할 수 있습니다.
> 
> #### 2. 데이터 캡슐화 및 관리
> 모델 클래스는 데이터와 그 데이터에 관련된 동작을 하나의 객체로 캡슐화합니다. 이는 데이터 무결성을 유지하고, 데이터와 관련된 모든 처리를 한 곳에서 관리할 수 있도록 도와줍니다.
> ### DataMapper.cs 의 역할
> - DataMapper.cs는 데이터 모델을 정의합니다. 즉, 데이터를 담을 수 있는 객체(클래스)들을 정의합니다
> - 맵퍼가 데이터를 담기는 하지만 사실상 그냥 클래스를 정의하는 곳이고 데이터의 로드와 관리, 그리고 접근은 DataManager를 통해 이루어 진다 말 그대로 **DataMapper.cs는 모델을 정의하는 곳**
> - 그래서 아래와 같이 데이터로 읽어온걸 class로 매핑시켜줄 수 있게 Character, Skill 등 모델을 추가(정의)하는 것
>   ![[Pasted image 20240807223549.png]]
    
> [!tip]+ xml 데이터 불러오기, 저장, 관리 - DataManger.cs
> ### DataManager.cs의 역할
> 1. **데이터 로드**: 외부 데이터 소스에서 데이터를 불러옵니다.
> 2. **데이터 파싱**: 불러온 데이터를 파싱하여 Character, Skill, Buff 등의 객체로 변환합니다. 
> 3. **데이터 저장**: 파싱된 데이터를 딕셔너리와 같은 데이터 구조에 저장합니다.
> 4. **데이터 제공**: 저장된 데이터를 다른 클래스나 메서드가 사용할 수 있도록 제공합니다
> ### 게임 시작 시 1번만 로드해도 되는 데이터들을 읽어두고 딕셔너리에 저장하기 위해 변수 선언
> ![[Pasted image 20240807223942.png]]
> ### 데이터 로드 경로 설정 할 수 있도록 전역변수 선언
> ![[Pasted image 20240807223955.png]]
> ### 위에서 말했듯 DataMager는 로드 된 데이터를 저장하는 곳이기 때문에 이곳으로 접근을 시키기 위해 싱글턴 추가
> ![[Pasted image 20240807224048.png]]
> ### 위에서 Awake에 ReadAllDataOnAWake() 함수를 통해 데이터 매니저 생성시점에서 모든 데이터 읽어오도록 하고 있음
> ![[Pasted image 20240807224101.png]]
> ### 불러온 데이터 딕셔너리에 저장
> - 47 line에서 데이터를 가져오고 최종적으로는 78 라인에서 데이터를 저장한다
> - 그 과정에서 토큰분리는 csv에서 쉼표로 구분해서 스트링 데이터 분리하는것처럼 스트링 데이터를 분리시키는 작업임 (아래 , 쉼표로로 분리해놓은 스트링 데이터임)
> 
> ![[Pasted image 20240807224149.png]]
> 
>  ![[Pasted image 20240807224131.png]]
> ### 프로티로 접근 가능하도록 get; private set; 으로 수정
> ![[Pasted image 20240807224215.png]]
> 
> ![[Pasted image 20240807224228.png]]

> [!tip]+ 겟셋 사용 이유 GPT 답변 
>  get; private set;을 사용하면 속성의 값을 외부에서 읽을 수 있지만, 해당 값을 변경할 수 있는 코드는 DataManager 클래스 내부에만 있을 수 있습니다. 이를 통해 데이터의 무결성을 보호하고, 의도하지 않은 변경을 방지할 수 있습니다. 이를 이해하기 쉽게 예제와 함께 설명해드리겠습니다.
> ### 예제
> 먼저 DataManager 클래스의 일부를 살펴보겠습니다:
> ``` csharp
> using System.Collections;
> using System.Collections.Generic;
> using UnityEngine;
> 
> public class DataManager : MonoBehaviour
> {
>     public static DataManager Inst { get; private set; }
> 
>     public Dictionary<int, Character> LoadedCharacterList { get; private set; }
>     public Dictionary<string, Skill> LoadedSkillList { get; private set; }
>     public Dictionary<string, Buff> LoadedBuffList { get; private set; }
> 
>     private void Awake()
>     {
>         Inst = this;
>         ReadAllDataOnAwake();
>     }
> 
>     private void ReadAllDataOnAwake()
>     {
>         ReadData(nameof(Character));
>         ReadData(nameof(Skill));
>         ReadData(nameof(Buff));
>     }
> 
>     private void ReadData(string tableName)
>     {
>         switch (tableName)
>         {
>             case "Character":
>                 ReadCharacterTable(tableName);
>                 break;
>             case "Skill":
>                 ReadSkillTable(tableName);
>                 break;
>             case "Buff":
>                 ReadBuffTable(tableName);
>                 break;
>         }
>     }
> 
>     private void ReadCharacterTable(string tableName)
>     {
>         LoadedCharacterList = new Dictionary<int, Character>();
>         // 데이터 로드 로직...
>     }
>     
>     private void ReadSkillTable(string tableName)
>     {
>         LoadedSkillList = new Dictionary<string, Skill>();
>         // 데이터 로드 로직...
>     }
> 
>     private void ReadBuffTable(string tableName)
>     {
>         LoadedBuffList = new Dictionary<string, Buff>();
>         // 데이터 로드 로직...
>     }
> }
> ```
> ### get; private set;의 의미
>위 코드에서 LoadedCharacterList, LoadedSkillList, LoadedBuffList 속성들은 public 접근자와 함께 get; private set;으로 정의되어 있습니다. 이는 다음과 같은 의미를 갖습니다:
> 1. **읽기 가능**: 다른 클래스에서 이 속성들을 읽을 수 있습니다.
> 2. **쓰기 제한**: 이 속성들은 DataManager 클래스 내부에서만 값을 변경할 수 있습니다.
> ### 예제: 데이터 접근 및 수정
> 다른 클래스에서 DataManager의 속성들을 접근하는 예제입니다.
> ``` csharp
> public class GameManager : MonoBehaviour
> {
>     private void Start()
>     {
>         // 데이터 읽기 - 가능
>         var characters = DataManager.Inst.LoadedCharacterList;
>         Debug.Log("Loaded characters: " + characters.Count);
> 
>         // 데이터 쓰기 - 불가능 (컴파일 에러)
>         // DataManager.Inst.LoadedCharacterList = new Dictionary<int, Character>();
> 
>         // DataManager 내에서 속성 값 설정 - 가능
>         DataManager.Inst.UpdateCharacterList();
>     }
> }
> ```
> 그리고 DataManager 내부에서 속성 값을 설정하는 예제입니다:
> ``` csharp
> public class DataManager : MonoBehaviour
> {
>     public static DataManager Inst { get; private set; }
> 
>     public Dictionary<int, Character> LoadedCharacterList { get; private set; }
>     public Dictionary<string, Skill> LoadedSkillList { get; private set; }
>     public Dictionary<string, Buff> LoadedBuffList { get; private set; }
> 
>     private void Awake()
>     {
>         Inst = this;
>         ReadAllDataOnAwake();
>     }
> 
>     private void ReadAllDataOnAwake()
>     {
>         ReadData(nameof(Character));
>         ReadData(nameof(Skill));
>         ReadData(nameof(Buff));
>     }
> 
>     public void UpdateCharacterList()
>     {
>         // DataManager 클래스 내부에서 속성 값 변경 - 가능
>         LoadedCharacterList = new Dictionary<int, Character>
>         {
>             { 1, new Character { DataId = 1, Name = "Hero" } },
>             { 2, new Character { DataId = 2, Name = "Villain" } }
>         };
>     }
> 
>     private void ReadCharacterTable(string tableName)
>     {
>         LoadedCharacterList = new Dictionary<int, Character>();
>         // 데이터 로드 로직...
>     }
> }
> ```
> ### 요약
> - get; private set;은 속성의 값을 외부에서 읽을 수 있게 하되, 값을 변경(set)하는 것은 해당 클래스 내부에서만 가능하게 합니다.
> - 이는 데이터의 무결성을 보호하고, 의도하지 않은 변경을 방지하는 데 유용합니다.
> - 외부 클래스에서는 속성 값을 읽기만 할 수 있으며, 변경하고 싶다면 DataManager 클래스에 메서드를 추가하여 이를 통해 속성 값을 변경할 수 있습니다.

위 과정을 간략하게 그려보자면 아래와 같다
![[Pasted image 20240807230340.png]]

> [!tip]+ 확장 메서드 추가 - DatamanagerExtention.cs
> ### 여기서 확장메서드를 사용하는 이유와 장점은?
> 데이터를 가져오는 메서드 정의들을 DataManager 에다가 하지 않고 별도로 Exttention이라는 걸 만들어서 정의하는 것으로 Datamanager에 코드를 적지 않음으로서 코드 관리가 쉬워지고 가독성이 좋아진다
>### 캐릭터 데이터 가져오는 메서드 추가
>![[Pasted image 20240807230753.png]]
>### 버프, 스킬 데이터 가져오는 메서드도 추가
>![[Pasted image 20240807230824.png]]
>### 특정 데이터 가져오는 메서드 추가
>![[Pasted image 20240807230840.png]]
>### 특정 데이터 가공해서 가져오는 데이터 추가
>![[Pasted image 20240807230859.png]]

> [!tip]+ 필요한 데이터 View에서 가져오기 - CharacterinfoView.cs
> 확장메서드에서 추가한 메서드를 참조할 때 위에서 설명한 것과 같이 DataManager에 추가 된 메서드 이므로 접근할 때도 마찬가지로 아래와 같이 Datamanager.Inst + 함수이름 으로 접근하면 된다.
> ``` csharp
>  DataManager.Inst.GetCharacterData(_currentCharacter) !!!!
> ```
> 
> ``` csharp
> using System.Collections;
> using System.Collections.Generic;
> using UnityEngine;
> using UnityEngine.UI;
> 
> public class CharacterInfoView : MonoBehaviour
> {
>     [SerializeField] Text Text_Name;
>     [SerializeField] Text Text_Description;
>     [SerializeField] GameObject Transform_SlotRoot;
>     [SerializeField] GameObject Prefab_SkillSlot;
> 
>     private int _currentCharacter = 3;
> 
>     public void Start()
>     {
>         SetCharacterInfo();
>     }
> 
>     private void SetCharacterInfo()
>     {
>         var character = DataManager.Inst.GetCharacterData(_currentCharacter);
>         if(character == null)
>         {
>             return;
>         }
> 
>         Text_Name.text = character.Name;
>         Text_Description.text = character.Description;
> 
>         SetSkillUI(character);
>     }
> 
>     private void SetSkillUI(Character character)
>     {
>         var skillNameList = character.SkillClassNameList;
>         if (skillNameList.Count > 0)
>         {
>             foreach(var skillClassName in skillNameList)
>             {
>                 var gObj = Instantiate(Prefab_SkillSlot, Transform_SlotRoot.transform);
>                 var skillSlot = gObj.GetComponent<SkillSlotView>();
>                 if (skillSlot == null)
>                     continue;
> 
>                 skillSlot.SetUI(skillClassName);
>             }
>         }
>     }
> }
> 
> ```


### 결과
게임 실행 시 플레이어의 이름이나 이미지 경로 등을 찾아 아래와 같이 세팅이 된다

![[Pasted image 20240807231526.png]]