
>[!NOTE]+ 인터페이스와 추상클래스 개념 익혀보기
>블로그 정리 : https://kimyir.tistory.com/18
>유튜브 정리 : https://www.youtube.com/watch?v=Is2bdBpncHA
>추상클래스 개념 정리 블로그 1. : https://goranitv.tistory.com/10

# [인터페이스]


인터페이스 사용 예시 
무기 교체 기능은 깃허브 https://github.com/jong212/Note  주소에 올려 놓았고 
b8b9b98d3eadec78020c8bb14d1434b3d37f914f 커밋 체크아웃 후 확인해 보면 된다.
> [!NOTE]- 인터페이스의 핵심 다형성을 지킨 예시 코드
> ### - 인터페이스 = Promise
> 인터페이스는 약속이다
> ![[Pasted image 20240907160315.png]]
> 
> ### - 구체적인 구현
>  공격 기능과 장전 기능을 정의하였고 이는 클래스에서 구현해야한다는 약속과도 같다.
> 따라서 Gun, Sword 클래스에서는 인터페이스를 상속받은 다음 약속 된 메서드들을 구현한다.
> ![[Pasted image 20240907160326.png]] ![[Pasted image 20240907160340.png]]
> 
> ### - 의존성 주입 
> 
> 위와 같이 인터페이스를 상속받으면 이점이 뭐가 있을까?
> `Player`는 구체적으로 `Sword`나 `Gun`이 어떻게 동작하는지는 알 필요가 없고, 그저 `IWeapon` 인터페이스를 통해 무기를 사용한다.
> 
> ![[Pasted image 20240907160402.png]]
> 
> 게임을 실행하기 전 구조를 설명하자면
> 현재 구조는 부모오브젝트에 Player오브젝트를 추가하였고 자식 오브젝트에는 Sword,Gun 스크립트를 장착했다
> 
> 1. 게임을 시작하면  런타임 단계에서 자식 오브젝트 중 IWeapon 을 상속받은 모든 오브젝트를 찾아내서 List에 담는다
> 2. EquiWeopon 메서드에 의해 기본 무기로 첫 번쨰 무기인 Gun을 선택한다
> 3. R을 누르면 Update에서 Reload가 실행되면서 리스트 첫 번째 인터페이스로 등록 된 Gun 스크립트의 메서드가 실행된다
> ![[Pasted image 20240907161346.png]]
> 
> 게임 시작 후 바로 R을 눌러본 상태
> ![[Pasted image 20240907161614.png]]
> 
> 2번 클릭 해서 무기 교체 후 R을 눌러 본 상태
> ![[Pasted image 20240907161647.png]]
> 
> 이와 같이 플레이어에서 자유롭게 무기 변경이 가능한 것을 보았다
> 


# [추상클래스]
 
### 추상 클래스란?
유니티에서 추상 클래스(Abstract Class)는 객체 지향 프로그래밍에서 사용하는 개념으로, 하나 이상의 추상 메서드를 포함한 클래스야. 추상 클래스는 인스턴스화될 수 없으며, 다른 클래스들이 상속받아 사용할 수 있는 일종의 '템플릿' 역할을 한다.

### 추상 클래스 사용하는 이유

**추상 클래스**는 **공통된 동작이나 속성을 공유**하는 여러 클래스의 기본 틀을 제공합니다. **공통적인 기능은 기본적으로 구현**하고, 개별적인 기능은 자식 클래스에서 구체화하도록 강제합니다. 이를 통해 코드의 중복을 줄이고, 유지보수성을 높일 수 있습니다.

> [!NOTE]- 추상 클래스 직접 인스턴스화 할 수 없는 이유
> 
> - **추상 클래스는 완전한 클래스가 아니며**, 특정 기능의 **틀만** 제공합니다. 따라서 추상 클래스 자체로는 **인스턴스를 만들 수 없습니다**.
> - 예를 들어, `Weapon`이라는 추상 클래스는 다양한 무기들이 공통으로 가져야 할 특성이나 동작을 정의할 수 있지만, **자체적으로는 구체적인 무기를 의미하지 않습니다**. **그래서 `Weapon`이라는 추상 클래스로는 직접 인스턴스를 생성할 수 없습니다**.
> 
> ### 자식 클래스를 통한 인스턴스화
> 
> - **구체적인 객체**를 만들기 위해서는 추상 클래스인 `Weapon`을 상속받은 자식 클래스를 사용해야 합니다. 예를 들어, `Sword`와 같은 구체적인 자식 클래스를 통해 인스턴스를 생성할 수 있습니다.
> - `Sword` 클래스는 `Weapon`의 모든 특성을 물려받으며, 구체적인 무기(`Sword`)로서 동작합니다.
> 
> ### 추상 클래스가 자체적으로 인스턴스화할 경우 발생하는 오류
> 
> ``` csharp
> public abstract class Weapon
> {
>     public abstract void Attack();
> }
> 
> public class Sword : Weapon
> {
>     public override void Attack()
>     {
>         Debug.Log("Swinging the sword!");
>     }
> }
> 
> // 이 코드는 컴파일 오류가 발생합니다.
> // Weapon myWeapon = new Weapon();  // 불가능: 추상 클래스는 직접 인스턴스화할 수 없습니다.
> 
> Weapon myWeapon = new Sword();  // 가능: Sword(자식 클래스)로 인스턴스화
> myWeapon.Attack();  // 출력: "Swinging the sword!"
> 
> ```
> 
> ## 설명 및 결론
> 
> - **추상 클래스 자체로 인스턴스화 불가**:
>     
>     - `Weapon myWeapon = new Weapon();`는 허용되지 않습니다. `Weapon`은 추상 클래스이기 때문에, 이 클래스로 직접 객체를 생성할 수 없습니다.
> - **자식 클래스를 통해 인스턴스화**:
>     
>     - `Weapon myWeapon = new Sword();`는 허용됩니다. `Sword`는 `Weapon`을 상속받은 구체적인 클래스이므로, 이를 통해 인스턴스를 생성할 수 있습니다.
>     - 이렇게 생성된 `myWeapon`은 `Weapon` **타입의 참조 변수**로서, 실제로는 `Sword` 객체를 가리키고 있습니다.
> - **결론**:
>     
>     - **추상 클래스는 직접 인스턴스를 생성할 수 없습니다**. 이는 추상 클래스가 구체적인 객체를 표현하기 위한 것이 아니라, **공통된 동작이나 속성을 정의**하기 위한 것이기 때문입니다.
>     - **구체적인 자식 클래스를 통해 인스턴스화**해야 하며, 이 경우 부모 클래스의 참조 변수(`Weapon myWeapon`)로 자식 클래스의 인스턴스(`new Sword()`)를 가리킬 수 있습니다.

>[!Note]- 추상 클래 자체는 인스턴스 할 수 없는 이유 코드로 보기
>**추상 클래스는 직접 인스턴스를 생성할 수 없습니다**. 이는 추상 클래스가 구체적인 객체를 표현하기 위한 것이 아니라, **공통된 동작이나 속성을 정의**하기 위한 것이기 때문입니다. 아래 사진을 보면 Weapon은 추상클래스이다 
>![[Pasted image 20240907215446.png]]
>![[Pasted image 20240907215510.png]]
> 추상클래스는 **구체적인 자식 클래스를 통해 인스턴스화**해야 하며, 이 경우 부모 클래스의 참조 변수(`Weapon myWeapon`)로 자식 클래스의 인스턴스(`new Sword()`)를 가리킬 수 있습니다. 만약 추상클래스가 인스턴스화가 가능했다면 new Sword가 아닌 new Weapon 으로 가능했을 것이다
>![[Pasted image 20240907215521.png]]

> [!NOTE]- 참조 변수와 타입, 그리고 다형성
> ### **참조 변수와 타입**
> 
> 1. **참조 변수**:
>     
>     - **참조 변수**는 객체(인스턴스)를 가리키는 변수입니다. 예를 들어, `Parent parentRef`는 `Parent` 클래스의 참조 변수입니다. 이 변수는 `Parent` 클래스 또는 그 자식 클래스의 인스턴스를 가리킬 수 있습니다.
> 2. **타입**:
>     
>     - **타입**은 변수가 어떤 종류의 데이터를 가리킬 수 있는지를 정의합니다. 예를 들어, `Parent`는 클래스 타입이고, `parentRef`는 `Parent` 타입의 참조 변수입니다.
> 
> ### **참조 변수를 통해 호출한다는 것**
> 
> - **참조 변수를 통해 호출**한다는 것은, 그 참조 변수를 사용하여 메서드를 호출하는 것을 의미합니다.
> - 예를 들어, `parentRef.VirtualMethod();`라고 하면, `parentRef`가 가리키는 객체의 `VirtualMethod()` 메서드를 호출하라는 의미입니다.
> 

> [!NOTE]- 다형성(polymorphism)과 메서드 숨기기
> ### **다형성(polymorphism)**
> 
> - **다형성**이 작동하려면, **부모 클래스의 메서드가 `virtual`로 선언**되어 있어야 하고, 자식 클래스에서 그 메서드를 `override`로 재정의해야 합니다.
> - 다형성은 **부모 클래스 타입의 참조 변수**를 통해서도 자식 클래스에서 재정의된 메서드를 호출할 수 있게 해주는 중요한 객체 지향 프로그래밍 개념입니다.
> 
> ### **메서드 숨기기(`new` 키워드)**
> 
> - `new` 키워드는 자식 클래스에서 부모 클래스의 동일한 이름의 메서드를 **다시 정의**하는 데 사용됩니다.
> - 이 경우, 자식 클래스의 인스턴스라도 **부모 클래스 타입의 참조 변수를 통해 호출**하면 **부모 클래스의 메서드**가 호출됩니다. 이는 다형성이 적용되지 않는 경우입니다.
> 
> ### **타입의 참조 변수를 통해 호출하면**
> 
> 이 문장을 이해하기 위해 상황을 가정해보겠습니다.
> 
> ``` csharp
> Parent parentRef = new Child();  // 부모 클래스 타입의 참조 변수 parentRef가 자식 클래스의 인스턴스를 가리킴
> parentRef.NormalMethod();        // 타입의 참조 변수를 통해 메서드를 호출
> 
> ```
> 
> - **Parent parentRef**: `parentRef`는 `Parent` 타입의 참조 변수입니다. 이 변수는 `Parent` 클래스를 가리킬 수 있습니다. 여기서 중요한 점은, **참조 변수의 타입**이 `Parent`라는 것입니다.
> - **new Child()**: 실제로는 `Child` 클래스의 인스턴스를 생성합니다. `parentRef`는 `Child` 인스턴스를 가리키지만, 참조 변수의 타입은 여전히 `Parent`입니다.
> 
> ### **타입의 참조 변수를 통해 메서드를 호출**:
> 
> - **`parentRef.NormalMethod();`**: 이 문장은 **참조 변수(`parentRef`)의 타입**인 `Parent`에 정의된 `NormalMethod()`를 호출하라는 의미입니다.
> - **결과**: `parentRef`가 가리키는 실제 인스턴스(`new Child()`)에 관계없이, 참조 변수의 타입(`Parent`)에 따라 **부모 클래스의 `NormalMethod()`**가 호출됩니다.
> 
> ### **왜 이렇게 되나요?**
> 
> - `NormalMethod()`는 `Parent` 클래스에서 **`virtual`로 선언되지 않았기 때문에**, 자식 클래스에서 `new` 키워드로 다시 정의해도 부모 클래스의 메서드가 호출됩니다.
> - **참조 변수의 타입**이 `Parent`이므로, `Parent` 클래스에 정의된 메서드만 호출할 수 있습니다.
> - **다형성**이 적용되는 경우는 **참조 변수의 타입**이 부모 클래스일지라도, 메서드가 `virtual`로 선언되고 자식 클래스에서 `override`로 재정의된 경우입니다. 이때는 자식 클래스의 메서드가 호출됩니다.
> 
> ### **요약**
> 
> - **"타입의 참조 변수를 통해 호출하면"**이라는 표현은 **참조 변수의 타입에 따라 메서드를 호출한다**는 의미입니다.
> - `Parent` 타입의 참조 변수를 사용하여 `NormalMethod()`를 호출하면, **참조 변수의 타입**이 `Parent`이기 때문에 **부모 클래스의 메서드**가 호출됩니다.
> - 이는 다형성이 적용되지 않는 상황으로, 자식 클래스에서 메서드를 `new` 키워드로 숨긴 경우에 해당됩니다.
> 
> ### 결론
> 
> - **추상 클래스는 구체적인 객체를 생성할 수 없으며**, 자식 클래스를 통해서만 인스턴스를 생성할 수 있습니다.
> - **참조 변수의 타입**에 따라 호출되는 메서드가 달라질 수 있으며, **다형성**이 적용되려면 부모 클래스의 메서드가 `virtual`로 선언되고, 자식 클래스에서 `override`로 재정의되어야 합니다.
> - **메서드 숨기기(`new`)**는 다형성이 적용되지 않으며, 부모 클래스의 참조 변수를 통해 호출될 때 부모 클래스의 메서드가 호출됩니다.

> [!NOTE]- 추상 클래스 예시 코드 virtual, override, base
> 아래 예시는 추상 클래스와 `virtual`, `override`, `base` 키워드를 모두 사용하는 예시입니다. 이 코드를 통해 추상 클래스, 자식 클래스에서의 재정의, 그리고 `base` 키워드를 사용한 부모 클래스 메서드 호출을 확인할 수 있습니다.
> 
> ### **코드 예시: 추상 클래스와 재정의**
> 
> ```csharp
> using UnityEngine;
> 
> // 추상 클래스 정의
> public abstract class Animal
> {
>     // 추상 메서드: 자식 클래스에서 반드시 구현해야 함
>     public abstract void Speak();
> 
>     // 가상 메서드: 자식 클래스에서 재정의할 수 있음
>     public virtual void Move()
>     {
>         Debug.Log("The animal moves...");
>     }
> }
> 
> // 자식 클래스 1: Dog 클래스
> public class Dog : Animal
> {
>     // 추상 메서드를 재정의하여 구체적인 구현 제공
>     public override void Speak()
>     {
>         Debug.Log("The dog barks: Woof Woof!");
>     }
> 
>     // 가상 메서드를 재정의
>     public override void Move()
>     {
>         // 부모 클래스의 Move() 메서드 호출
>         base.Move();
>         // 추가 동작 정의
>         Debug.Log("The dog runs swiftly.");
>     }
> }
> 
> // 자식 클래스 2: Bird 클래스
> public class Bird : Animal
> {
>     // 추상 메서드를 재정의하여 구체적인 구현 제공
>     public override void Speak()
>     {
>         Debug.Log("The bird sings: Tweet Tweet!");
>     }
> 
>     // 가상 메서드를 재정의
>     public override void Move()
>     {
>         // 부모 클래스의 Move() 메서드 호출
>         base.Move();
>         // 추가 동작 정의
>         Debug.Log("The bird flies high.");
>     }
> }
> 
> // 테스트용 스크립트
> public class TestScript : MonoBehaviour
> {
>     void Start()
>     {
>         // 부모 클래스 타입의 참조 변수에 자식 클래스의 인스턴스 할당
>         Animal myDog = new Dog();
>         Animal myBird = new Bird();
> 
>         // Dog 클래스의 메서드 호출
>         myDog.Speak();  // 출력: "The dog barks: Woof Woof!"
>         myDog.Move();   // 출력:
>                         // "The animal moves..." -> base를 통해 부모 클래스 메서드 호출
>                         // "The dog runs swiftly." -> Dog 클래스의 추가 동작
> 
>         // Bird 클래스의 메서드 호출
>         myBird.Speak(); // 출력: "The bird sings: Tweet Tweet!"
>         myBird.Move();  // 출력:
>                         // "The animal moves..." -> base를 통해 부모 클래스 메서드 호출
>                         // "The bird flies high." -> Bird 클래스의 추가 동작
>     }
> }
> ```
> 
> ### **코드 설명**
> 
> 1. **추상 클래스 `Animal`**:
>    - **`Speak()`**: 이 메서드는 추상 메서드로 정의되어, 자식 클래스에서 반드시 재정의해야 합니다.
>    - **`Move()`**: 이 메서드는 `virtual`로 정의되어, 자식 클래스에서 재정의할 수 있습니다.
> 
> 2. **자식 클래스 `Dog`**:
>    - **`Speak()`**: 추상 메서드를 재정의하여 구체적인 동작을 정의합니다.
>    - **`Move()`**: 가상 메서드를 재정의합니다. 재정의된 메서드에서 **`base.Move()`**를 사용하여 부모 클래스의 기본 동작을 호출하고, 그 위에 추가적인 동작을 덧붙입니다.
> 
> 3. **자식 클래스 `Bird`**:
>    - **`Speak()`**: 마찬가지로, 추상 메서드를 재정의하여 구체적인 동작을 정의합니다.
>    - **`Move()`**: 가상 메서드를 재정의하고, 부모 클래스의 메서드를 호출한 후 추가적인 동작을 정의합니다.
> 
> 4. **테스트용 스크립트 `TestScript`**:
>    - **`Animal myDog = new Dog();`**: 부모 클래스 타입의 참조 변수를 사용하여 `Dog` 인스턴스를 가리킵니다.
>    - **`myDog.Speak()`** 및 **`myDog.Move()`**를 호출하면, `Dog` 클래스에서 재정의된 메서드가 호출됩니다.
>    - 같은 방식으로, **`Animal myBird = new Bird();`**에서 `Bird` 클래스의 재정의된 메서드가 호출됩니다.
> 
> ### **결론**
> 
> - **추상 클래스**는 자식 클래스에서 구현해야 할 공통적인 틀을 제공합니다.
> - **`virtual` 메서드**는 부모 클래스에서 기본 동작을 정의하며, 자식 클래스에서 이를 재정의(`override`)할 수 있습니다.
> - **`base` 키워드**를 사용하면 자식 클래스에서 부모 클래스의 메서드를 호출할 수 있습니다. 이를 통해 부모 클래스의 기본 동작을 유지하면서, 추가적인 동작을 정의할 수 있습니다.
> - **다형성**을 통해, 부모 클래스의 참조 변수를 사용하여 자식 클래스의 재정의된 메서드를 호출할 수 있습니다.
> 
> 이 예시를 통해 추상 클래스와 관련된 개념들이 더욱 명확하게 이해되셨기를 바랍니다!

# 인터페이스와 추상클래스의 차이
추상 클래스는 부분적인 구현을 제공하면서 상속 관계를 형성하고, 인터페이스는 구현 없이 필요한 동작을 정의한다는 차이가 있습니다