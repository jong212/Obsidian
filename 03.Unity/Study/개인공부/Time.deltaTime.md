
| Git          |                                                        |
| ------------ | ------------------------------------------------------ |
| BranchName   |                                                        |
| RefFile      |                                                        |
| Memo         | Time.deltaTime이란 **마지막 프레임이 완료된 후 경과한 시간**을 반환합니다.<br> |
| MOC_Category | [[기초 - MOC]]                                           |
d
## 이해하기 까지 GPT에게 물어봤더 과정

> [!NOTE]- Time.deltaTime개념이 뭔지 GPT한테 물어봄
> 
> 프레임 수와 `Time.deltaTime` 개념을 더 쉽게 설명해볼게요. 여러 용어와 개념이 혼란스러울 수 있으니, 차근차근 설명해볼게요.
> 
> ### 1. **프레임과 프레임 간격**
>    - 게임은 여러 개의 **프레임**을 계속해서 그리는 방식으로 움직임을 표현해요. 이때 각 프레임이 하나의 "장면"이라고 생각하면 됩니다.
>    - **FPS (Frames Per Second)**는 초당 몇 개의 프레임이 그려지는지를 말하는데, 예를 들어 FPS가 60이면 1초 동안 60번의 장면을 그린다는 뜻이에요. 따라서 FPS가 높을수록 더 부드러운 화면이 만들어집니다.
> 
> ### 2. **프레임 간의 시간 간격 (`Time.deltaTime`)**
>    - 각 프레임이 그려지는 데는 약간의 시간이 걸립니다. 이 시간이 컴퓨터 성능에 따라 달라질 수 있어요. 
>    - 예를 들어, 성능이 좋은 컴퓨터에서는 프레임이 빠르게 그려지지만, 성능이 낮은 컴퓨터에서는 프레임이 더 천천히 그려집니다.
>    - **`Time.deltaTime`**은 **이전 프레임이 그려진 시점과 현재 프레임이 그려진 시점 사이의 시간 차이**를 의미합니다. 즉, 프레임 간의 **시간 간격**이에요.
> 
> ### 3. **왜 `Time.deltaTime`이 필요할까요?**
>    만약 게임 속 캐릭터가 초당 5미터를 이동해야 한다고 가정해봅시다. 하지만 프레임이 빠르면 빠를수록 더 자주 화면을 그리게 되죠. 
> 
>    - **문제**: 각 프레임마다 고정된 거리만큼 이동하게 만들면, 프레임이 빠른 컴퓨터에서는 캐릭터가 더 빠르게 이동하고, 프레임이 느린 컴퓨터에서는 캐릭터가 더 느리게 이동하게 됩니다. 즉, 컴퓨터 성능에 따라 게임 속 캐릭터의 움직임이 달라지게 되는 거죠.
> 
>    - **해결책**: `Time.deltaTime`을 곱해주면 각 프레임이 그려지는 시간이 얼마나 걸렸는지 알 수 있으니, 프레임이 빠르든 느리든 캐릭터가 일정한 속도로 움직이게 만들 수 있습니다.
> 
> ### 4. **실제 예시로 이해하기**
>    - **초당 5미터 이동**하는 캐릭터를 만들어 보자고 가정해봅시다. 
>    - **FPS가 60**이라면, 1초에 60개의 프레임이 그려집니다. 각 프레임이 그려지는 데 걸리는 시간(`Time.deltaTime`)은 약 1/60초, 즉 0.0167초입니다.
>    - 그럼 이때 이동 거리는 `5미터 * 0.0167초` = 약 0.0835미터가 됩니다. 즉, 캐릭터는 1프레임마다 0.0835미터씩 이동하게 됩니다.
>    
>    - **FPS가 30**이라면, 1초에 30개의 프레임이 그려집니다. 각 프레임이 그려지는 데 걸리는 시간은 1/30초, 즉 0.0333초입니다.
>    - 그럼 이때 이동 거리는 `5미터 * 0.0333초` = 약 0.167미터가 됩니다. 즉, 캐릭터는 1프레임마다 0.167미터씩 이동하게 됩니다.
> 
> 이렇게 `Time.deltaTime`을 곱해주면, 프레임이 빠르거나 느리더라도 캐릭터는 항상 초당 5미터씩 이동하게 되어, **프레임 속도에 관계없이 일정한 움직임**을 유지할 수 있습니다.
> 
> ### 다시 요약하면:
> 
> - **프레임(FPS)**: 게임이 초당 몇 개의 장면을 그리는지.
> - **`Time.deltaTime`**: 각 프레임이 그려지는데 걸린 시간(이전 프레임과 현재 프레임 사이의 시간 차이).
> - **`Time.deltaTime`을 사용하는 이유**: 컴퓨터 성능에 따라 프레임 속도가 다르더라도, 캐릭터의 움직임을 일정하게 유지하기 위해.
> 
> 이해를 돕기 위해서는 직접 간단한 코드를 실행해 보면서 프레임 수와 `Time.deltaTime`을 테스트해 보는 것도 큰 도움이 될 거예요.

> [!NOTE]- 사용자마다 FPS가 몇인지를 어떻게 체크하는지 궁금해서 다시 GPT에게 물어봄
> 아, 이제 질문의 요지를 정확히 이해했습니다! 유니티에서 어떻게 특정 사용자의 FPS를 알아내는지 궁금하신 거죠.
> 
> 유니티는 실제로 각 사용자의 FPS를 자동으로 계산하고, 이를 개발자가 사용하는 방식으로 데이터를 제공합니다. **`Time.deltaTime`**이 그 역할을 하는데, 이 값은 자동으로 계산되기 때문에 개발자가 사용자마다 직접 FPS를 추적하지 않아도 됩니다. Unity가 `Time.deltaTime`을 통해 각 프레임이 얼마나 빨리 처리되었는지를 알 수 있게 해주는 것이죠.
> 
> ### 더 자세한 설명
> 
> 유니티가 제공하는 `Time.deltaTime`은 각 프레임 간의 시간을 자동으로 계산해줍니다. FPS는 초당 프레임 수를 의미하므로, 이를 반대로 생각하면 **한 프레임이 처리되는 데 걸린 시간**이 바로 `Time.deltaTime`입니다.
> 
> - **예시**: 만약 FPS가 60이라면, 1초에 60개의 프레임이 처리되기 때문에 한 프레임이 처리되는 데 걸리는 시간은 **1/60초**, 즉 약 0.0167초가 됩니다. 이 값이 `Time.deltaTime`으로 반환됩니다.
> - **또 다른 예시**: 만약 FPS가 30이라면, 한 프레임이 처리되는 데 걸리는 시간은 **1/30초**, 즉 약 0.0333초가 됩니다. 이 값이 `Time.deltaTime`으로 반환됩니다.
> 
> 즉, 유니티는 프레임 간 경과 시간을 알아내어 자동으로 `Time.deltaTime`에 저장하므로, 개발자는 굳이 각 사용자의 FPS를 직접 알 필요 없이 **`Time.deltaTime`을 사용하여 이동 거리나 속도를 프레임 독립적으로 계산**할 수 있습니다.
> 
> ### 이동 거리 계산
> 
> 게임에서 캐릭터의 이동을 프레임 독립적으로 처리하려면, 다음과 같은 방법을 사용합니다:
> 
> ```csharp
> float speed = 5.0f; // 초당 5미터 이동
> float moveDistance = speed * Time.deltaTime;
> transform.Translate(Vector3.forward * moveDistance);
> ```
> 
> 위 코드에서 **`Time.deltaTime`**을 곱하면 각 프레임에서 경과한 시간만큼의 거리만큼 캐릭터가 이동하게 됩니다. 프레임이 많아지든(높은 FPS) 적어지든(낮은 FPS) 상관없이 **캐릭터는 1초에 5미터를 이동**하게 되는 거죠.
> 
> ### 요약
> 
> - **`Time.deltaTime`**은 유니티가 각 프레임마다 경과한 시간을 자동으로 계산해줍니다.
> - 개발자는 사용자마다 FPS가 몇인지 직접 알 필요 없이 `Time.deltaTime`을 사용해 프레임 독립적인 이동을 구현할 수 있습니다.
> - FPS가 다르더라도, `Time.deltaTime`을 곱해서 이동 거리나 속도를 계산하면 모든 사용자가 같은 경험을 하게 됩니다.

> [!NOTE]- 이해를 거의 다 해서 마지막으로 지금까지 물어본 내용 GPT에게 요약해 달라고 했음
> 
> ### 상황 정리
> 
> 우리는 `Time.deltaTime`과 `speed`를 곱해서 캐릭터가 프레임마다 이동해야 하는 거리를 계산합니다. 하지만 각 사용자마다 `Time.deltaTime`이 다를 수 있죠. 예를 들어, 사용자 A는 FPS가 60이고 사용자 B는 FPS가 30이라고 가정해봅시다.
> 
> ### 헷갈리는 이유
> 
> FPS가 다르기 때문에 `Time.deltaTime` 값도 서로 다릅니다. 예를 들어, 사용자 A의 `Time.deltaTime`이 0.0167초(60FPS 기준)이고, 사용자 B의 `Time.deltaTime`이 0.0333초(30FPS 기준)라고 가정하면, 프레임마다 계산된 이동 거리가 다르게 보일 수 있습니다. 
> 
> 즉, 사용자 A와 B가 프레임마다 이동하는 거리가 다르다면, **어떻게 그들이 결국 같은 거리를 이동하게 되는가**라는 의문이 생길 수 있습니다.
> 
> ### 수학적 이해
> 
> #### 1. **프레임마다 이동하는 거리 계산**
> 이동하는 거리는 `speed * Time.deltaTime`입니다. 예를 들어, `speed = 5.0f`라고 하고, 1초에 5미터를 이동해야 한다고 가정하겠습니다.
> 
> - 사용자 A의 경우 (FPS가 60):  
>   `Time.deltaTime`은 약 0.0167초입니다.  
>   프레임마다 이동 거리는 `5.0f * 0.0167초 = 0.0835미터`입니다.
> 
> - 사용자 B의 경우 (FPS가 30):  
>   `Time.deltaTime`은 약 0.0333초입니다.  
>   프레임마다 이동 거리는 `5.0f * 0.0333초 = 0.167미터`입니다.
> 
> #### 2. **동일한 시간 동안 이동 거리 비교**
> 이제 1초 동안 A와 B가 각각 몇 프레임을 그렸는지 생각해보면, 결국 이동하는 총 거리가 동일하다는 사실을 알 수 있습니다.
> 
> - **사용자 A (60FPS)**:  
>   1초 동안 60개의 프레임을 그리게 되므로, 각 프레임마다 0.0835미터를 이동합니다.  
>   1초 동안 총 이동 거리는 `0.0835미터 * 60프레임 = 5미터`입니다.
> 
> - **사용자 B (30FPS)**:  
>   1초 동안 30개의 프레임을 그리게 되므로, 각 프레임마다 0.167미터를 이동합니다.  
>   1초 동안 총 이동 거리는 `0.167미터 * 30프레임 = 5미터`입니다.
> 
> #### 3. **결론: 결국 같은 거리를 이동**
> - 사용자 A와 B는 프레임마다 이동하는 거리는 다르지만, FPS가 높을수록 더 많은 프레임을 그리기 때문에 프레임 간 이동 거리가 더 작습니다.
> - 반대로 FPS가 낮은 사용자 B는 프레임이 적지만, 각 프레임당 이동 거리가 더 깁니다.
> - 따라서, **1초 동안 이동한 총 거리는 두 사용자 모두 동일**하게 5미터가 됩니다.
> 
> ### `Vector3.forward`와의 곱셈
> 
> `Vector3.forward`는 단순히 이동 방향을 나타냅니다. 이 값은 `(0, 0, 1)`로, Z축 방향으로 1 단위 이동하는 벡터입니다. 이를 `speed * Time.deltaTime`으로 계산된 이동 거리와 곱하면, 해당 방향으로 캐릭터가 얼마나 이동해야 하는지 알 수 있습니다.
> 
> 즉, 각 사용자마다 `speed * Time.deltaTime` 값은 다를 수 있지만, 이를 방향 벡터(`Vector3.forward`)와 곱해주면 각 프레임마다 해당 방향으로 이동할 거리만큼 캐릭터가 이동하게 되는 것이죠.
> 
> ### 요약
> 
> - **프레임마다 이동하는 거리는 각 사용자마다 다릅니다**, 왜냐하면 FPS에 따라 `Time.deltaTime`이 다르기 때문입니다.
> - **하지만 전체적인 시간으로 보면** FPS가 낮은 사용자는 프레임이 적고, 각 프레임에서 더 많이 이동하고, FPS가 높은 사용자는 프레임이 많고 각 프레임에서 더 적게 이동하기 때문에, **결과적으로 같은 시간이 지나면 동일한 거리를 이동**하게 됩니다.
> - `Vector3.forward`는 단순히 방향을 정해주는 벡터로, `speed * Time.deltaTime`으로 계산된 거리를 해당 방향으로 이동시키는 역할을 합니다.

## 정 이해가 가지 않는다면
 **`Time.deltaTime`이 들어간 계산은 프레임마다 무언갈 처리하는 방식**이라고 이해하면 된다

## 사용 예시 10가지

> [!NOTE]- Example10
> `Time.deltaTime`을 사용하는 짧은 예시 코드를 10개 이상 준비했습니다. 이 예시들은 모두 **프레임 속도에 독립적으로** 일정한 동작을 수행하도록 하는 방법들을 보여줍니다.
> 
> ### 1. **캐릭터 이동 속도 제어**
> 캐릭터가 일정한 속도로 앞으로 이동하는 예시입니다.
> 
> ```csharp
> void Update()
> {
>     float speed = 5f;
>     transform.Translate(Vector3.forward * speed * Time.deltaTime);
> }
> ```
> 
> ### 2. **카메라 회전**
> 카메라가 일정한 속도로 회전하는 예시입니다.
> 
> ```csharp
> void Update()
> {
>     float rotationSpeed = 50f;
>     transform.Rotate(Vector3.up, rotationSpeed * Time.deltaTime);
> }
> ```
> 
> ### 3. **점진적인 크기 증가**
> 오브젝트의 크기를 서서히 키우는 예시입니다.
> 
> ```csharp
> void Update()
> {
>     Vector3 scaleIncrease = new Vector3(1, 1, 1);
>     transform.localScale += scaleIncrease * Time.deltaTime;
> }
> ```
> 
> ### 4. **감속 처리**
> 물체의 속도를 서서히 줄이는 예시입니다.
> 
> ```csharp
> float speed = 10f;
> float deceleration = 5f;
> 
> void Update()
> {
>     if (speed > 0)
>     {
>         speed -= deceleration * Time.deltaTime;
>         speed = Mathf.Max(speed, 0);
>         transform.Translate(Vector3.forward * speed * Time.deltaTime);
>     }
> }
> ```
> 
> ### 5. **선형 보간(Lerp)**
> 오브젝트의 위치를 일정한 속도로 목표 위치로 선형 보간하는 예시입니다.
> 
> ```csharp
> Vector3 targetPosition = new Vector3(10, 0, 0);
> void Update()
> {
>     transform.position = Vector3.Lerp(transform.position, targetPosition, 0.1f * Time.deltaTime);
> }
> ```
> 
> ### 6. **부드러운 감속**
> 오브젝트의 속도를 선형 보간 방식으로 부드럽게 줄이는 예시입니다.
> 
> ```csharp
> float speed = 10f;
> void Update()
> {
>     speed = Mathf.Lerp(speed, 0f, 0.5f * Time.deltaTime);
>     transform.Translate(Vector3.forward * speed * Time.deltaTime);
> }
> ```
> 
> ### 8. **간단한 애니메이션**
> 오브젝트가 위로 일정한 속도로 움직이는 애니메이션입니다.
> 
> ```csharp
> void Update()
> {
>     float speed = 3f;
>     transform.Translate(Vector3.up * speed * Time.deltaTime);
> }
> ```
> 
> ### 9. **시간에 따른 스케일 감소**
> 오브젝트의 크기를 서서히 줄이는 예시입니다.
> 
> ```csharp
> void Update()
> {
>     float shrinkRate = 0.5f;
>     transform.localScale -= new Vector3(shrinkRate, shrinkRate, shrinkRate) * Time.deltaTime;
> }
> ```
> 
> ### 10. **중력 효과 구현**
> 오브젝트가 중력에 의해 떨어지게 만드는 간단한 중력 효과입니다.
> 
> ```csharp
> float gravity = -9.8f;
> void Update()
> {
>     Vector3 fallVelocity = new Vector3(0, gravity * Time.deltaTime, 0);
>     transform.Translate(fallVelocity);
> }
> ```
> 
> ### 11. **FPS 표시기**
> 현재 프레임 속도를 표시하는 간단한 예시입니다.
> 
> ```csharp
> void OnGUI()
> {
>     float fps = 1.0f / Time.deltaTime;
>     GUI.Label(new Rect(10, 10, 100, 20), "FPS: " + fps);
> }
> ```
> 
> 
> 이와 같은 `Time.deltaTime`을 사용하는 예시들은 **프레임 독립적인 속도, 회전, 크기 변경, 이동 및 기타 애니메이션을 구현**하는 데 유용합니다. 이를 통해 각 프레임에서 경과한 시간에 따라 동작을 제어할 수 있습니다.

