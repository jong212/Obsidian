
| Git          |              |
| ------------ | ------------ |
| BranchName   |              |
| RefFile      |              |
| Memo         |              |
| MOC_Category | [[기초 - MOC]] |
|              |              |
|              |              |
|              |              |
>[!NOTE]- 재정의란? (GPT 답변)
> 부모 클래스의 메서드를 재정의(override)할 때, 자식 클래스에서 부모 클래스의 로직을 완전히 변경하거나 추가할 수 있습니다. 이를 통해 부모 클래스의 기본 동작을 필요에 따라 수정할 수 있습니다.
> 
> ### 부모 로직을 변경하는 방법
> 
> 1. **부모 메서드를 호출하지 않고 완전히 새로운 로직을 작성하기**:
>    자식 클래스에서 부모 클래스의 메서드를 재정의할 때, 부모 메서드를 호출하지 않고, 자식 클래스에서 새로운 로직을 작성할 수 있습니다. 이 경우, 부모 클래스의 동작은 무시되고 자식 클래스에서 정의한 동작만 실행됩니다.
> 
> 2. **부모 메서드를 호출한 후에 추가적인 동작을 정의하기**:
>    부모 클래스의 기본 동작을 유지하면서, 그 후에 자식 클래스에서 추가적인 로직을 실행할 수 있습니다. 이 경우 `base.메서드명()`을 사용하여 부모의 메서드를 호출한 후에 자식 클래스의 추가 동작을 정의할 수 있습니다.
> 
> ### 예시
> 
> #### 1. 부모 로직을 완전히 변경하기
> 부모 클래스의 `CollisionChecks()` 메서드가 땅과 벽의 충돌만 감지한다고 가정해 보겠습니다. 자식 클래스에서 이 동작을 완전히 바꿔서 다른 로직을 실행하도록 할 수 있습니다.
> 
> ```csharp
> // 부모 클래스
> public class Entity : MonoBehaviour
> {
>     protected virtual void CollisionChecks()
>     {
>         // 부모 클래스의 충돌 감지 로직
>         Debug.Log("Parent Collision Check");
>     }
> }
> 
> // 자식 클래스
> public class Player : Entity
> {
>     protected override void CollisionChecks()
>     {
>         // 부모 로직을 호출하지 않고, 새로운 로직으로 완전히 변경
>         Debug.Log("Child Collision Check - Custom Logic");
>     }
> }
> ```
> 
> 이 경우, 자식 클래스 `Player`에서 `CollisionChecks()`가 호출되면 부모 클래스의 충돌 감지 로직은 실행되지 않고, 자식 클래스에서 정의한 새로운 로직이 실행됩니다.
> 
> #### 2. 부모 로직을 유지하면서 추가 로직을 작성하기
> 부모 클래스의 기본 동작을 유지하면서 자식 클래스에서 추가 동작을 더하고 싶다면, `base.메서드명()`을 호출하여 부모의 동작을 먼저 수행한 다음, 추가 작업을 진행할 수 있습니다.
> 
> ```csharp
> // 부모 클래스
> public class Entity : MonoBehaviour
> {
>     protected virtual void CollisionChecks()
>     {
>         // 부모 클래스의 충돌 감지 로직
>         Debug.Log("Parent Collision Check");
>     }
> }
> 
> // 자식 클래스
> public class Player : Entity
> {
>     protected override void CollisionChecks()
>     {
>         // 부모 클래스의 충돌 감지 로직을 먼저 호출
>         base.CollisionChecks();
> 
>         // 자식 클래스에서 추가 로직 실행
>         Debug.Log("Child Collision Check - Additional Logic");
>     }
> }
> ```
> 
> 이 경우, `Player` 클래스에서 `CollisionChecks()` 메서드가 호출되면, 출력은 다음과 같이 나타납니다:
> 
> ```
> Parent Collision Check
> Child Collision Check - Additional Logic
> ```
> 
> 즉, 부모의 기본 충돌 감지 로직이 실행된 후, 자식 클래스에서 추가로 정의한 로직이 실행됩니다.
> 
> ### 결론
> 
> - 부모 클래스의 로직을 **완전히 변경**하고 싶다면, `override` 메서드에서 `base.메서드명()`을 호출하지 않고 자식 클래스에서 새로운 로직을 작성하면 됩니다.
> - 부모 클래스의 로직을 **유지하면서 추가 동작**을 더하고 싶다면, `base.메서드명()`을 호출하여 부모의 로직을 먼저 실행한 후, 자식 클래스에서 추가 작업을 수행할 수 있습니다.

> [!NOTE]- 재정의 Override 헷갈리는 것 GPT 답변
> 좋은 질문입니다! 부모 클래스의 `Start()` 메서드가 있고, 자식 클래스에서 `private`으로 `Start()` 메서드를 다시 정의한다면, 그 두 메서드는 **완전히 별개의 메서드**로 취급됩니다. 이것은 **재정의(override)**와는 다릅니다.
> 
> ### 중요한 차이점
> 
> 1. **재정의(Override)**:
>    - 재정의는 부모 클래스의 메서드를 자식 클래스에서 다시 정의하는 것입니다. 부모 클래스의 메서드가 `virtual`로 선언되고, 자식 클래스에서 `override` 키워드를 사용해 부모의 메서드를 재정의합니다.
>    - 재정의된 메서드는 **부모 클래스의 메서드를 덮어씌웁니다**. 즉, 부모 클래스에서 호출되는 메서드가 아닌, 자식 클래스에서 재정의된 메서드가 호출됩니다.
>    
> 2. **새로운 메서드 정의 (같은 이름으로)**:
>    - 자식 클래스에서 `private`으로 같은 이름의 메서드를 정의하는 것은 부모 클래스의 메서드를 덮어쓰는 것이 아니라, **자식 클래스 내에서만 유효한 별도의 메서드를 만드는 것**입니다.
>    - 이 경우, 부모 클래스의 `Start()` 메서드는 여전히 존재하며, 부모 클래스에서 호출될 수 있습니다. 하지만 자식 클래스의 인스턴스는 자식 클래스 내에서 정의된 `Start()` 메서드를 호출하게 됩니다.
> 
> ### 코드 예시 1: 재정의(Override)
> 
> ```csharp
> using UnityEngine;
> 
> public class Entity : MonoBehaviour
> {
>     // 부모 클래스에서 virtual로 선언된 Start 메서드
>     protected virtual void Start()
>     {
>         Debug.Log("Entity's Start");
>     }
> }
> 
> public class Player : Entity
> {
>     // 자식 클래스에서 재정의(override)된 Start 메서드
>     protected override void Start()
>     {
>         base.Start(); // 부모 클래스의 Start 메서드를 호출
>         Debug.Log("Player's Start");
>     }
> }
> ```
> 
> - **실행 결과**:
>   ```
>   Entity's Start
>   Player's Start
>   ```
>   자식 클래스에서 `Start()` 메서드를 재정의했고, 부모 클래스의 메서드를 호출한 후 추가적인 작업을 수행합니다. 이 방식은 부모의 `Start()`를 확장하는 것입니다.
> 
> ### 코드 예시 2: 자식 클래스에서 새로운 `private Start()` 정의
> 
> ```csharp
> using UnityEngine;
> 
> public class Entity : MonoBehaviour
> {
>     // 부모 클래스의 Start 메서드 (private이 아닌 메서드)
>     private void Start()
>     {
>         Debug.Log("Entity's Start");
>     }
> }
> 
> public class Player : Entity
> {
>     // 자식 클래스에서 같은 이름으로 새롭게 정의된 Start 메서드
>     private void Start()
>     {
>         Debug.Log("Player's Start");
>     }
> }
> ```
> 
> - **실행 결과**:
>   ```
>   Player's Start
>   ```
>   여기서는 `Player` 클래스의 `Start()` 메서드만 실행됩니다. **부모 클래스의 `Start()` 메서드는 호출되지 않습니다**. 이는 재정의가 아니라, 자식 클래스에 새로운 메서드를 정의한 것이기 때문입니다. 이 두 메서드는 독립적으로 동작하며, 서로 영향을 주지 않습니다.
> 
> ### 결론
> 
> - **재정의(override)**는 부모 클래스의 메서드를 자식 클래스에서 다시 정의하여, 부모 클래스에서 정의된 동작을 덮어씌우거나 확장하는 방식입니다. 이때 부모 클래스의 메서드를 호출하려면 `base.Method()`를 사용합니다.
>   
> - **같은 이름의 `private` 메서드를 정의하는 것**은 부모 클래스의 메서드를 덮어쓰는 것이 아니라, 자식 클래스 내에서만 사용되는 별도의 메서드를 정의하는 것입니다. 부모 클래스의 메서드는 여전히 존재하지만, 자식 클래스에서는 이를 사용할 수 없습니다.
> 
> 이 두 개념은 기능적으로 매우 다릅니다. 재정의는 부모 클래스의 메서드 동작을 변경하는 것이고, 자식 클래스에서 같은 이름의 `private` 메서드를 정의하는 것은 그저 다른 메서드를 만들 뿐입니다.