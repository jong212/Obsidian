


## 1. 캡슐화

>[!Tip]+ 한 줄 정리
>캡슐화를 통해 데이터의 **무분별한 접근을 방지**하고, 객체의 상태를 안전하게 유지하며 코드의 유연성을 높일 수 있다
>
>**GPT 가 생각하는 캡슐화**
>캡슐화는 내가 설계한 코드가 의도한 대로만 동작하도록 보호막을 씌우는 것 같아. 이렇게 하면 외부에서 객체의 내부 상태를 무작정 변경하거나 잘못 사용하지 못하게 막을 수 있어서, 나중에 버그를 줄이고 유지보수도 훨씬 쉬워져. 결국, 나를 포함한 팀원들이 코드의 의도와 사용 방법을 쉽게 이해하고 안전하게 작업할 수 있게 도와주는 거라고 생각해.

무분별한 접근을 왜 **방지**해야 하는 걸까? 아래와 같은 예시상황을 가정해 보자.

==문제 상황==
만약 우리가 `Player`라는 클래스에서 플레이어의 나이를 관리한다고 가정해봅시다. 
간단하게 public 필드를 사용하여 구현할 수 있다.
``` csharp
public class Player
{
    public int Age;
}
```

이렇게 하면 외부에서 `Player` 객체의 `Age`를 직접 수정할 수 있다.
``` csharp
Player player = new Player();
player.Age = -5; // 문제 발생: 나이가 음수일 수 없음
```

위의 코드에서는 음수 나이를 설정할 수 있는데, 이는 논리적으로 말이 되지 않는다.
이 문제는 캡슐화를 통해 게터세터를 이용해서 해결할 수 있다

``` csharp
public class Player
{
    private int age;

    public int Age
    {
        get { return age; }
        set 
        {
            if (value < 0)
            {
                age = 0; // 음수 값이 들어올 경우 0으로 설정
            }
            else
            {
                age = value;
            }
        }
    }
}
```

이제 외부에서 Age를 설정할 때 음수 값이 들어오면 0으로 자동으로 바꿔줌
``` csharp
Player player = new Player();
player.Age = -5; // 세터가 음수 값을 0으로 바꿔줌
Console.WriteLine(player.Age); // 출력: 0
```

이런 방식으로 게터와 세터를 활용하면 데이터를 안전하게 보호하면서도 유연한 설계를 할 수 있습니다.
 
## 2. 추상화
객체의 공통적인 특성을 추출하여 코드의 복잡성을 줄입니다.

## 3. 상속
상속은 부모 클래스로부터 공통된 변수와 함수, 인터페이스를 그대로 물려받는 것을 말합니다.

## 4. 다형성
다형성은 같은 인터페이스나 부모 클래스를 공유하는 여러 객체가 각각 다른 방식으로 동작할 수 있게 합니다. 예를 들어, "공격"이라는 메서드를 각 캐릭터 클래스에서 다르게 구현할 수 있습니다.