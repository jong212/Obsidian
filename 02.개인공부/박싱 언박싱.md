
| 카테고리     | [[기초 - MOC]]                                                                                                          |
| -------- | --------------------------------------------------------------------------------------------------------------------- |
| 글 작성 이유  | 알고리즘 공부 과정에서 박싱 언박싱에 대한 용어가 나왔고 아직은 잘 모르지만 처리 속도가 늦어진다는? <br>내용을 본 것 같아서 어떠한 과정에서 박싱 언 박싱이 발생하는지 알아 보기 위해 글을 작성하였습니다. |
| 공부 후 느낀점 |                                                                                                                       |
| 참고사이트    |                                                                                                                       |
## <center>박싱</center>
### 박싱 언박싱 정의

박싱 : 값 => 참조 형식으로 변환하는 것
언박싱 : 참조 => 값 형식으로 변환하는 것

**다시 말해서**

==박싱은== 값 형식을 오브젝트 형식으로 변환하거나 
값 형식을 인터페이스 형식으로 변환 할 때 발생한다 (2가지 상황에서 박싱이 일어나는 것이다.)


**두 가지 상황을 예시로 설명**

1. 값 형식 => object 형식으로 변환 할 때
***
// ==여기서는 박싱이 일어나지 않는다==
// 이 줄에서는 int 타입의 값 123이 스택 메모리에 저장 됨 박싱이 일어나지 않는다 
// 그냥 값 형식의 변수에 값을 할당하는 일반적인 과정이기 때문. 
`int number = 123; `      

// ==여기서 박싱이 일어난다== 
// 여기서 number는 값 형식 (int)이고, obj는 참조형식(object)이기 때문
// CLR이 number의 값을 힙 메모리에 생성된 Object 타입의 박스에 담습니다.
// 그런 다음 obj는 그 힙 메모리의 참조를 가리키게 됩니다 (그래서 참조 변수라고 부르는 듯)
`object obj = number; `
***

2. 값 형식 => 구현 된 임의 인터페이스 형식 으로 변환 할 때
***
public interface IExample
{
    void DoSomething();
}

struct MyStruct : IExample
{
    public void DoSomething()
    {
        // 구현 내용
    }
}

MyStruct ms = new MyStruct();
IExample example = ms; // 여기서 박싱 발생
***
### 근데 박싱은 왜 하는걸까?
박싱(Boxing)은 ==값 타입(value type)을 참조 타입(reference type)으로 변환==하기 위해 필요한 과정이라고 함
* 그렇다면 어떠한 경우에 값을 참조 타입으로 변환해야 할까?
	* 값 타입을 참조타입 처럼 다루어야하는 상황이 있기 때문 이라고 한다 아래와 같은 예제의 상황일 때 인듯



근데 number는 값타입 변수인데 어떻게 박싱이 되는걸까 ? 하는 의문이 들었다
* 알고보니 C#에서는 값타입 (int,float,struct)을 참조타입(object 또는 해당 인터페이스타입)으로 변환할 때 ==암시적으로 박싱이 발생==한다고 한다.
- PrintObject 메서드는 object 타입의 매개변수를 요구하므로, 값 타입인 number를 참조 타입인 object로 변환해야 한다.
- 이 변환 과정에서 **박싱이 자동으로 발생**하며, number의 값이 힙(heap) 메모리에 object로 감싸져 저장되고, 그 참조가 obj 매개변수로 전달됩니다.


### 그렇다면 박싱이 암시적으로(자동으로) 발생하는 경우는?
**[1]. 값 타입을 object 타입에 할당할 때**
- `int`는 값 타입이고, `object`는 참조 타입입니다.
- 값 타입인 `number`를 참조 타입인 `obj`에 할당하면서 박싱이 자동으로 발생합니다.
``` csharp
int number = 123;
object obj = number; // 여기서 박싱 발생
```

**[2]. 값 타입을 인터페이스 타입에 할당할 때**
- `MyStruct`는 값 타입(struct)이고, `IExample`은 참조 타입인 인터페이스입니다.
- 값 타입인 `ms`를 인터페이스 타입인 `example`에 할당하면서 박싱이 자동으로 발생합니다.
``` csharp
public interface IExample
{
    void DoSomething();
}

struct MyStruct : IExample
{
    public void DoSomething()
    {
        // 구현 내용
    }
}

MyStruct ms = new MyStruct();
IExample example = ms; // 여기서 박싱 발생

```

**[3]. 메서드의 매개변수가 참조 타입일 때 값 타입을 전달하면**
-  PrintObject 메서드는 object 타입의 매개변수를 받습니다.
- 값 타입인 number를 전달하면서 박싱이 자동으로 발생합니다.
``` csharp
void PrintObject(object obj)
{
    Console.WriteLine(obj);
}

int number = 123;
PrintObject(number); // 여기서 박싱 발생
```

**[4]. 비제네릭 컬렉션에 값 타입을 추가할 때**
``` csharp
ArrayList list = new ArrayList();
int number = 123;
list.Add(number); // 여기서 박싱 발생

```
- ArrayList는 object 타입을 요소로 받는 비제네릭 컬렉션입니다.
- 값 타입인 number를 컬렉션에 추가하면서 박싱이 자동으로 발생합니다.

### 반대로 언박싱은?
- 언박싱(Unboxing): 박싱된 객체를 다시 값 타입으로 변환할 때는 **명시적 캐스팅**이 필요하며, 이때 언박싱이 발생합니다.
``` csharp
    object obj = 123;      // 박싱 발생
    int number = (int)obj; // 언박싱 발생 (명시적 캐스팅 필요)
```

### 주의사항 
박싱과 언박싱은 추가적인 메모리 할당과 연산을 필요로 하기 때문에 성능에 영향을 줄 수 있습니다. 특히 반복문 내에서 빈번하게 발생하면 성능 저하의 원인이 될 수 있으므로 주의해야 합니다..

### 박싱을 피하는 방법
박싱 언박싱은 성능에 영향을 끼친다는데 그렇다면 박싱 언박싱을 어떻게 피할까?

**제네릭(Generic) 사용** 
제네릭을 활용하면 박싱 없이 값 타입을 처리할 수 있다. 근데 이 방법은 그냥 매게변수가 object가 아니라서 당연히 박싱도 안싱이 안 된것이고 값>참조 형식으로 바뀐것도 아니다 그냥 값을 전달한 것이다.
``` csharp
void PrintObject<T>(T obj)
{
    Console.WriteLine(obj);
}

int number = 123;
PrintObject(number); // 박싱 없이 호출 가능
```
### 주의사항
만약 메서드 내부에서 값 타입을 참조 타입으로 변환하는 작업이 있다면 박싱이 발생할 수 있다.
``` csharp
void PrintObject<T>(T obj)
{
    object o = obj; // 여기서 박싱 발생
    Console.WriteLine(o);
}

```