
| 카테고리     | [[기초 - MOC]]               |
| -------- | -------------------------- |
| 글 작성 이유  | 게임의 성능과 비주얼 퀄리티를 최적화 하기 위해 |
| 공부 후 느낀점 |                            |
| 참고사이트    |                            |
## <center>랜ㄷ링ㅍ이ㅍ라ㅇ</center>
### 렌더링 파이프라인 이란
간단히 말하면 3D 화면을 2차원으로 표현하는 과정이다

과정을 요약하면 아래와 같다 

유니티 엔진을 포함한 대부분의 3D그래픽 엔진은 최종적으로 3D데이터를 2D이미지로 변환해서 
우리가 보는 화면에 렌더링을 하는데 이 과정을 보고 ==렌더링 파이프라인== 라고 부른다.
### 파이프라인에 대해 단계적으로 알아보자
렌더링 파이프라인(Rendering Pipeline)은 3D 모델, 조명, 카메라, 셰이더 등을 통해 게임 그래픽을 화면에 렌더링하는 일련의 단계들을 말한다. 이 파이프라인은 그래픽 카드에서 수행되는 여러 단계를 포함하여 최종 이미지를 생성한다.

**과거의 렌더링 파이프라인 (Built-in)**
우선 2018년 이전의 유니티는 지금처럼 urp,hdrp 와 같은 파이프라인을 제공하지 않았고 ==빌트인만 제공==을 했었음 그 당시 유니티에서 공식적으로 지원하는 셰이더 제작 방법은 Surface Shader 라고 부르는 코딩 입력 방식으로 셰이더를 작성했었는데 ==문제는 파이프라인이 유연하지 않고== 사용자가 직접 세부 단게에  큰 영향을 미칠 수 없었다고 함

**새로운 렌더링 파이프라인(URP,HDRP)**
그래서 유니티에서는 2018년부터 SRP란 이름의 ==새로운 렌더링 파이프라인을 공개==했음 
그 이전 파이프라인은 빌트인으로 부르기로 결정했고 새로나온 SRP 파이프라인의 두 가지 템플릿으로 범용 작업을 하기 위해 URP,HDRP 파이프라인이 공개 됨 SRP 파이프라인은 유니티2 라고 불러도 될 정도로 빌트인파이프라인과 큰 차이가 있다고 함
### 렌더링 파이프 라인의 순서는?
>[!Tip]- [1]. 입력 어셈블리(Input Assembly) or 정점 조립
>
>일단 렌더링 파이프의 첫 번쨰 순서로는 "그래픽 카드가 버텍스 데이터" 를 받아오는 것입니다.
>다시 말해 3D 모델을 구성하는 버텍스**(정점)** 데이터가 GPU로 전달된다는 뜻입니다.
>여기서 "정점"은 3D 모델을 구성하는 기본 단위로, 위치(Position), 색상(Color), 텍스처 좌표(UV), 법선 벡터(Normal) 등의 정보를 포함합니다.
> 
> **정점 조립이란?**
> 이 단계에서는 버텍스와 폴리곤(삼각형 등) 간의 관계를 정의하여, 3D 모델의 기본 골격을 형성합니다.
> 버텍스 : 버텍스는 그냥 아래와 같은 점인데 아직 화면에는 아무것도 존재하지 않음 그냥 그래픽 카드 내부에서 값으로만 존재하는 데이터일 뿐, 버텍스는 3차원 공감에서 위치, 색상, 법선 텍스처 좌표 등의 데이터를 포함한 정점을 의미
> 
> **버텍스 데이터란?**
> - 위치(Position): 3D 모델의 정점이 공간에서 어디에 있는지를 나타내는 좌표로, 모델의 형상을 결정합니다.
> - 색상(Color): 정점 자체의 색상 정보로, 모델의 표면 색상을 결정하거나 조명, 텍스처와 혼합되어 최종 색상을 만듭니다.
> - 텍스처 좌표(UV): 3D 모델의 표면에 2D 텍스처 이미지를 어떻게 입힐지를 결정하는 좌표입니다.
> - 법선 벡터(Normal): 정점이 향하고 있는 방향을 나타내며, 조명 효과를 계산하는 데 사용됩니다.
> ![[Pasted image 20240812230311.png]]
> 
> **이 단계에서 결론은?**
> 1. 그래픽 카드가 버텍스로 이루어진 물체의 데이터 값(Position, Normal, Color)을 받아온 후 이 버텍스들의 정보를 가지고 버텍스들이 이어진 삼각형 면들을 만든다.
> 2. 이 단계에서 오브젝트의 기본적인 형태가 만들어지며, 이 후에 정점 셰이더로 데이터를 넘겨서 추가적인 변환과 처리가 이루어집니다.

> [!Tip]- [2]. 버텍스 셰이더(Vertex Shader)
> 버텍스 셰이더를 알기 전에 일단 피벗에 대한 개념을 알자
> **피벗**
> 피벗이 설정된 위치가 로컬 좌표계의 원점 (0, 0, 0)이 됩니다. 즉 피벗이 오브젝트의 어느 위치에 설정 되더라도 그 피벗의 위치가 로컬 좌표계의 기준이 되며 이 기준점이 바로 0 0 0 이다 다시 말 해 피벗의 위치한 지점이 로컬 좌표계의 ==기준점==이 되는 것.
> 
> **버텍스의 상대적 위치** 
> 오브젝트의 모든 ==버텍스==는 이 ==피벗(로컬 좌표계의 원점)을 기준으로 상대적인 좌표==를 가집니다. 예를 들어, 버텍스가 로컬 좌표계에서 (1, 2, 3)에 있다면, 이는 피벗에서 해당 방향으로 떨어져 있다는 의미입니다. 피벗의 위치가 바뀌면, 로컬 좌표계의 기준이 바뀌기 때문에, 각 버텍스의 로컬 좌표 값은 변경될 수 있습니다. 로컬 좌표계에서 버텍스의 위치는 피벗에 대해 상대적인 것이므로, 피벗 위치를 변경하는 것은 그 위치를 기준으로 로컬 좌표 값을 다시 계산하는 것입니다.
> 
> **버텍스 셰이더(Vertex Shader)**
> 버텍스 셰이더 단계에서는 오브젝트의 중심이 피벗으로 사용되며, 이 피벗은 로컬 좌표계에서 원점(0, 0, 0)으로 간주됩니다. 이 ==피벗을 기준으로 각 버텍스의 위치가 계산==됩니다. 부연설명을 하자면 피벗은 오브젝트의 중심부에 위치할 수도 있고, 사용자가 지정한 다른 위치에 있을 수도 있습니다. 하지만 일반적으로 모델링 과정에서 피벗은 오브젝트의 중심에 위치하게 됩니다.
> 
> **버텍스값을  옮기면 포지션 값이 바뀌는건가?**
> 버텍스를 (1, 2, 3)으로 옮긴다고 해서 오브젝트의 포지션(Position) 값이 (1, 2, 3)이 되는 것은 아닙니다. 
> 버텍스의 위치와 오브젝트의 포지션 값은 서로 다릅니다. 이를 자세히 설명해 드릴게요.
> 
> **오브젝트의 포지션(Position)**> 
> - 오브젝트의 포지션은 유니티 씬(Scene) 내에서 오브젝트 전체가 어디에 위치하는지를 나타냅니다.
> - 이 포지션 값은 월드 좌표계(World Coordinate System) 에서의 위치를 의미합니다.
> - 예를 들어, 오브젝트의 포지션이 (0, 0, 0)이라면, 오브젝트의 피벗(원점)이 씬의 원점에 위치하게 됩니다. 
> 
> **버텍스의 위치(Vertex Position)**> 
> - 버텍스의 위치는 로컬 좌표계(Local Coordinate System)에서 오브젝트의 피벗을 기준으로 한 개별 정점의 위치를 의미합니다.
> - 버텍스의 위치는 오브젝트 내부에서의 상대적인 위치를 나타내며, 오브젝트의 포지션 값과는 독립적입니다.
> 
> **예를 들어:**
> - 오브젝트의 포지션이 (0, 0, 0)이고, 버텍스의 위치가 로컬 좌표계에서 (1, 2, 3)이라면 이 버텍스는 오브젝트의 피벗에서 오른쪽으로 1, 위로 2, 앞쪽으로 3 단위 떨어져 있다는 의미입니다. 오브젝트 전체의 포지션은 (0, 0, 0)이지만, 해당 버텍스는 로컬 좌표계에서 (1, 2, 3) 위치에 있습니다.
> 
> - 오브젝트의 포지션을 (5, 5, 5)로 변경하더라도 버텍스의 위치는 여전히 로컬 좌표계에서 (1, 2, 3)입니다. 하지만 이 버텍스의 월드 좌표계에서의 위치는 오브젝트의 포지션에 따라 (6, 7, 8)이 됩니다 ((5, 5, 5) + (1, 2, 3)).
> 
> **피벗 && 버텍스 결론**
> - 버텍스의 위치를 (1, 2, 3)으로 옮겨도 **오브젝트의 포지션** 값은 변하지 않습니다.
> - 오브젝트의 포지션 값은 오브젝트 전체가 씬 내에서 어디에 위치하는지를 나타내며, 개별 버텍스의 위치는 로컬 좌표계에서 오브젝트의 피벗을 기준으로 설정됩니다.
> 
> 따라서 버텍스 위치를 (1, 2, 3)으로 변경해도 오브젝트의 포지션 값은 그대로 유지되며, 오브젝트는 씬에서 기존 위치에 있지만 버텍스는 오브젝트 내에서 이동하게 됩니다.
> 
> **자 그럼 버텍스 셰이더를 이해하기 위해 위 내용을 정리했다고 하면 버텍스 세이더에서는 무슨일을 하나?**
> 각 오브젝트는 자체적인 로컬 좌표계를 가지고 있으며, 이 좌표계의 원점(0, 0, 0)이 바로 오브젝트의 피벗입니다.
> - 모델 변환(Model Transform): 모델 공간의 버텍스 좌표를 월드 공간으로 변환합니다.
> - 월드 변환(World Transform): 월드 공간의 버텍스 좌표를 카메라의 뷰 공간으로 변환합니다.
> - 뷰 변환(View Transform): 뷰 공간의 버텍스 좌표를 클립 공간으로 변환합니다.
> - 프로젝션 변환(Projection Transform): 클립 공간에서 화면 공간으로 변환하기 위해 투영 매트릭스를 적용합니다.
> - 버텍스 출력(Vertex Output): 최종 변환된 버텍스 위치와 함께 텍스처 좌표, 색상, 법선 벡터 등의 데이터를 출력합니다.
> 

> [!Tip]- [3]. 테셀레이션(Tessellation, 선택적 단계)
> - 테셀레이션 컨트롤 셰이더(Tessellation Control Shader): 입력된 버텍스를 세분화하기 위한 패치를 생성합니다.
> - 테셀레이터(Tessellator): 패치를 세분화하여 더 많은 버텍스를 생성합니다.
> - 테셀레이션 평가 셰이더(Tessellation Evaluation Shader): 세분화된 버텍스의 위치를 계산하고 최종적으로 뷰 및 프로젝션 변환을 적용합니다.

> [!Tip]- [4]. 지오메트리 셰이더(Geometry Shader, 선택적 단계)
> - 프리미티브 처리(Primitive Processing): 버텍스 셰이더의 출력 또는 테셀레이션의 결과물을 받아 프리미티브를 조작하거나 추가 프리미티브를 생성합니다.
> - - 출력(Output): 최종적으로 삼각형이나 선 등의 프리미티브를 출력합니다.

> [!Tip]- [5]. 라스터라이제이션(Rasterization)
> - 프러스텀 컬링(Frustum Culling): 카메라의 뷰 프러스텀 밖에 있는 프리미티브는 제거하여 렌더링을 최적화합니다.
> - 스크린 스페이스 변환(Screen Space Transform): 클립 공간의 좌표를 화면 공간으로 변환하여 각 프리미티브를 2D 이미지로 변환합니다.
> - 프래그먼트 생성(Fragment Generation): 각 픽셀에 대해 하나 이상의 프래그먼트를 생성합니다. 프래그먼트는 각 픽셀의 잠재적 색상과 텍스처 좌표, 깊이 정보를 포함합니다.

>[!Tip]- [6]. 프래그먼트 셰이더(Fragment Shader, 또는 픽셀 셰이더)
>- 조명 계산(Lighting Calculation): 각 프래그먼트에 대해 조명 모델(예: Phong, Blinn-Phong)을 적용하여 최종 색상을 계산합니다.
>- 텍스처 샘플링(Texture Sampling): 프래그먼트의 텍스처 좌표를 이용해 텍스처 데이터를 가져와 적용합니다.
>- 환경 맵핑(Environment Mapping): 반사, 굴절 등의 효과를 시뮬레이션하여 프래그먼트에 적용합니다.
>- 출력(Output): 최종 색상, 알파(투명도), 깊이 값 등을 출력합니다.

> [!Tip]- [7]. 출력 병합 단계(Output Merger)
> - 깊이 테스트(Depth Testing): 깊이 버퍼를 사용하여 어떤 프래그먼트가 화면에 나타날지를 결정합니다.
> - 스텐실 테스트(Stencil Testing): 스텐실 버퍼를 사용해 프래그먼트의 렌더링 여부를 결정합니다.
> - 블렌딩(Blending): 여러 프래그먼트를 혼합하여 화면에 최종 색상을 결정합니다. 이는 주로 반투명 객체를 처리할 때 사용됩니다.
> - 출력(Output): 최종 이미지가 프레임 버퍼에 저장되고, 이후 디스플레이에 렌더링됩니다.
> 

> [!Tip]- [8]. 포스트 프로세싱(Post-Processing)
> - 블룸(Bloom): 밝은 부분이 번지는 효과를 적용합니다.
> - 모션 블러(Motion Blur): 움직임에 따라 흐릿해지는 효과를 적용합니다.
> - 색 보정(Color Grading): 최종 이미지의 색조, 명암, 채도를 조정합니다.
> - 피사계 심도(Depth of Field): 특정 거리에 초점을 맞추고 다른 부분은 흐릿하게 보이게 만듭니다.> 

// TO DO 전체적인 요약이 필요함









