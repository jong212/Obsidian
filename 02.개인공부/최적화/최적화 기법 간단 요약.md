### 최적화 기법 정리 사이트 메모
**배칭 최적화** : https://steadycodist.tistory.com/entry/Unity-%EC%9C%A0%EB%8B%88%ED%8B%B0-%EC%B5%9C%EC%A0%81%ED%99%94Unity-Batching

**병목 현상 해결방법** : https://medium.com/@thkim2/%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%93%9C%EB%A1%9C%EC%9A%B0%EC%BD%9C-%ED%95%98%EA%B8%B0-3-%EB%B3%91%EB%AA%A9-%ED%95%B4%EA%B2%B0-31835566d501


### 기법 정리 
오브젝트 풀링: 오브젝트 풀링은 새로운 오브젝트를 생성하는 대신 기존 오브젝트를 재사용하는 기법입니다. 이를 통해 오브젝트 생성 및 소멸에 따른 오버헤드를 줄이고 성능을 개선할 수 있습니다.  
  
세부 수준(LOD): 세부 수준은 카메라에서 멀리 떨어져 있는 오브젝트의 단순화된 버전을 사용하는 기법입니다. 이를 통해 렌더링해야 하는 폴리곤 수를 줄이고 성능을 개선할 수 있습니다.  
  
오클루전 컬링: 오클루전 컬링은 카메라에서 숨겨진 오브젝트를 렌더링하지 않는 기법입니다. 숨겨진 오브젝트를 렌더링하지 않음으로써 렌더링해야 하는 폴리곤의 수를 줄이고 성능을 개선할 수 있습니다.  
  
배치 렌더링: 일괄 렌더링은 여러 개체를 단일 드로우 호출로 결합하는 기법입니다. 이를 통해 렌더링 오버헤드를 줄이고 성능을 개선할 수 있습니다.  
  
코드 최적화: 코드 최적화에는 더 효율적으로 실행되도록 스크립트 코드를 최적화하는 작업이 포함됩니다. 여기에는 더 효율적인 데이터 구조를 사용하고 불필요한 계산을 피하며 메모리 할당을 최소화하는 것이 포함될 수 있습니다.  
  
텍스처 아틀라싱: 텍스처 아틀라싱은 여러 텍스처를 하나의 텍스처 아틀라스로 결합하는 기법입니다. 이를 통해 텍스처 전환 횟수를 줄이고 성능을 개선할 수 있습니다.  
  
스태틱 배치: 스태틱 배치는 빌드 시 정적 오브젝트를 단일 메시로 결합하는 기법입니다. 이를 통해 렌더링 오버헤드를 줄이고 성능을 개선할 수 있습니다.  
  
동적 해상도 스케일링: 동적 해상도 스케일링은 현재 성능에 따라 게임의 해상도를 동적으로 스케일링하는 기술입니다. 이를 통해 일관된 프레임 속도를 유지하고 저사양 장치에서 성능을 개선할 수 있습니다.  
  
스크립터블 오브젝트: 스크립터블 오브젝트는 스크립트 간에 공유할 수 있는 재사용 가능한 데이터 오브젝트를 생성하는 데 사용할 수 있는 Unity 기능입니다. 이를 통해 메모리 할당에 따른 오버헤드를 줄이고 성능을 개선할 수 있습니다.  
  
셰이더 최적화: 셰이더 최적화에는 게임에서 사용되는 셰이더를 보다 효율적으로 실행하도록 최적화하는 작업이 포함됩니다. 여기에는 셰이더에서 수행되는 계산 횟수 줄이기, 텍스처 샘플링 최적화, 사용되는 명령어 수 최소화 등이 포함될 수 있습니다.

| **최적화 기법**                                   | **개선 대상** | **설명**                                                                                   |
| -------------------------------------------- | --------- | ---------------------------------------------------------------------------------------- |
| **오브젝트 풀링 (Object Pooling)**                 | **CPU**   | 새로운 오브젝트의 생성 및 소멸을 줄여 CPU의 메모리 할당과 해제 오버헤드를 감소시킵니다. 이를 통해 스크립트 실행과 관련된 CPU 부하를 줄입니다.     |
| **세부 수준 (LOD)**                              | **GPU**   | 카메라에서 멀리 있는 오브젝트의 폴리곤 수를 줄여 GPU의 렌더링 부하를 감소시킵니다. 이는 그래픽 처리량을 줄여 GPU 성능을 최적화합니다.          |
| **오클루전 컬링 (Occlusion Culling)**              | **GPU**   | 카메라에 의해 가려진 오브젝트의 렌더링을 방지하여 GPU의 폴리곤 처리량을 줄입니다. 이는 GPU의 렌더링 작업을 효율화하여 성능을 향상시킵니다.        |
| **배치 렌더링 (Batch Rendering)**                 | **GPU**   | 여러 오브젝트를 단일 드로우 호출로 결합하여 GPU의 드로우 호출 오버헤드를 줄입니다. 이는 GPU의 렌더링 효율을 높여 성능을 개선합니다.           |
| **코드 최적화 (Code Optimization)**               | **CPU**   | 스크립트 코드의 효율성을 높여 CPU의 연산 부하를 감소시킵니다. 불필요한 계산을 피하고 데이터 구조를 최적화하여 CPU 성능을 향상시킵니다.          |
| **텍스처 아틀라싱 (Texture Atlasing)**              | **GPU**   | 여러 텍스처를 하나의 아틀라스로 결합하여 GPU의 텍스처 전환 횟수를 줄입니다. 이는 GPU의 상태 변경 오버헤드를 감소시켜 렌더링 성능을 최적화합니다.    |
| **스태틱 배치 (Static Batching)**                 | **GPU**   | 정적 오브젝트를 단일 메시로 결합하여 GPU의 드로우 호출 수를 줄입니다. 이는 GPU의 렌더링 효율을 높여 성능을 개선합니다.                  |
| **동적 해상도 스케일링 (Dynamic Resolution Scaling)** | **GPU**   | 현재 성능에 따라 게임의 해상도를 동적으로 조절하여 GPU의 렌더링 부하를 관리합니다. 이는 GPU의 처리량을 최적화하여 일관된 프레임 속도를 유지합니다.   |
| **스크립터블 오브젝트 (Scriptable Objects)**          | **CPU**   | 재사용 가능한 데이터 오브젝트를 통해 메모리 할당과 관련된 CPU 오버헤드를 줄입니다. 이는 스크립트 간 데이터 공유를 효율화하여 CPU 성능을 향상시킵니다. |
| **셰이더 최적화 (Shader Optimization)**            | **GPU**   | 셰이더 코드를 효율적으로 최적화하여 GPU의 연산 부하를 감소시킵니다. 계산 횟수를 줄이고 텍스처 샘플링을 최적화하여 GPU 렌더링 성능을 향상시킵니다.    |

### 요약

- **CPU 개선을 위한 최적화 기법**:
  - 오브젝트 풀링
  - 코드 최적화
  - 스크립터블 오브젝트

- **GPU 개선을 위한 최적화 기법**:
  - 세부 수준 (LOD)
  - 오클루전 컬링
  - 배치 렌더링
  - 텍스처 아틀라싱
  - 스태틱 배치
  - 동적 해상도 스케일링
  - 셰이더 최적화

이러한 최적화 기법들을 적절히 적용하면 CPU와 GPU 자원을 효율적으로 활용하여 유니티 프로젝트의 전반적인 성능을 크게 향상시킬 수 있습니다. 각 기법이 어떤 성능 병목을 해결하는지 이해하고, 프로젝트의 요구 사항과 현재 성능 상태에 따라 적절히 선택하여 적용하는 것이 중요합니다.